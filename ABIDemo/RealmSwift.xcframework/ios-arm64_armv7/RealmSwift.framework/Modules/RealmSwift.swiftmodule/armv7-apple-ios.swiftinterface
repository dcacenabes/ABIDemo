// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 5.4 (swiftlang-1205.0.26.9 clang-1205.0.19.55)
// swift-module-flags: -target armv7-apple-ios9.0 -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -O -module-name RealmSwift
import Foundation
import Realm.Private
import Realm
import Swift
public typealias PropertyType = Realm.RLMPropertyType
public typealias NotificationToken = Realm.RLMNotificationToken
public typealias ObjectBase = Realm.RLMObjectBase
public enum AnyRealmValue : Swift.Hashable {
  case none
  case int(Swift.Int)
  case bool(Swift.Bool)
  case float(Swift.Float)
  case double(Swift.Double)
  case string(Swift.String)
  case data(Foundation.Data)
  case date(Foundation.Date)
  case object(RealmSwift.Object)
  case objectId(RealmSwift.ObjectId)
  case decimal128(RealmSwift.Decimal128)
  case uuid(Foundation.UUID)
  public var intValue: Swift.Int? {
    get
  }
  public var boolValue: Swift.Bool? {
    get
  }
  public var floatValue: Swift.Float? {
    get
  }
  public var doubleValue: Swift.Double? {
    get
  }
  public var stringValue: Swift.String? {
    get
  }
  public var dataValue: Foundation.Data? {
    get
  }
  public var dateValue: Foundation.Date? {
    get
  }
  public var objectIdValue: RealmSwift.ObjectId? {
    get
  }
  public var decimal128Value: RealmSwift.Decimal128? {
    get
  }
  public var uuidValue: Foundation.UUID? {
    get
  }
  public func object<T>(_ objectType: T.Type) -> T? where T : RealmSwift.Object
  public var dynamicObject: RealmSwift.DynamicObject? {
    get
  }
  public init()
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: RealmSwift.AnyRealmValue, b: RealmSwift.AnyRealmValue) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public typealias AppConfiguration = Realm.RLMAppConfiguration
public typealias APIKeyAuth = Realm.RLMAPIKeyAuth
public typealias EmailPasswordAuth = Realm.RLMEmailPasswordAuth
public typealias EmailPasswordAuthOptionalErrorBlock = Realm.RLMEmailPasswordAuthOptionalErrorBlock
extension RLMEmailPasswordAuth {
  public func callResetPasswordFunction(email: Swift.String, password: Swift.String, args: [RealmSwift.AnyBSON], _ completion: @escaping RealmSwift.EmailPasswordAuthOptionalErrorBlock)
}
public typealias PushClient = Realm.RLMPushClient
public typealias UserAPIKey = Realm.RLMUserAPIKey
@frozen public enum Credentials {
  case facebook(accessToken: Swift.String)
  case google(serverAuthCode: Swift.String)
  case googleId(token: Swift.String)
  case apple(idToken: Swift.String)
  case emailPassword(email: Swift.String, password: Swift.String)
  case jwt(token: Swift.String)
  case function(payload: RealmSwift.Document)
  case userAPIKey(Swift.String)
  case serverAPIKey(Swift.String)
  case anonymous
}
public typealias App = Realm.RLMApp
extension RLMApp {
  public func login(credentials: RealmSwift.Credentials, _ completion: @escaping (Swift.Result<RealmSwift.User, Swift.Error>) -> Swift.Void)
}
@available(macOS 10.15, watchOS 6.0, iOS 13.0, iOSApplicationExtension 13.0, macOSApplicationExtension 10.15, tvOS 13.0, *)
public typealias ASLoginDelegate = Realm.RLMASLoginDelegate
@available(macOS 10.15, watchOS 6.0, iOS 13.0, iOSApplicationExtension 13.0, macOSApplicationExtension 10.15, tvOS 13.0, *)
extension RLMApp {
  public func setASAuthorizationControllerDelegate(for controller: AuthenticationServices.ASAuthorizationController)
}
extension RLMAPIKeyAuth {
  public func createAPIKey(named: Swift.String, completion: @escaping (Swift.Result<RealmSwift.UserAPIKey, Swift.Error>) -> Swift.Void)
  public func fetchAPIKey(_ objectId: RealmSwift.ObjectId, _ completion: @escaping (Swift.Result<RealmSwift.UserAPIKey, Swift.Error>) -> Swift.Void)
  public func fetchAPIKeys(_ completion: @escaping (Swift.Result<[RealmSwift.UserAPIKey], Swift.Error>) -> Swift.Void)
}
extension Int : RealmSwift._RealmSchemaDiscoverable {
  public static var _rlmType: RealmSwift.PropertyType {
    get
  }
}
extension Int8 : RealmSwift._RealmSchemaDiscoverable {
  public static var _rlmType: RealmSwift.PropertyType {
    get
  }
}
extension Int16 : RealmSwift._RealmSchemaDiscoverable {
  public static var _rlmType: RealmSwift.PropertyType {
    get
  }
}
extension Int32 : RealmSwift._RealmSchemaDiscoverable {
  public static var _rlmType: RealmSwift.PropertyType {
    get
  }
}
extension Int64 : RealmSwift._RealmSchemaDiscoverable {
  public static var _rlmType: RealmSwift.PropertyType {
    get
  }
}
extension Bool : RealmSwift._RealmSchemaDiscoverable {
  public static var _rlmType: RealmSwift.PropertyType {
    get
  }
}
extension Float : RealmSwift._RealmSchemaDiscoverable {
  public static var _rlmType: RealmSwift.PropertyType {
    get
  }
}
extension Double : RealmSwift._RealmSchemaDiscoverable {
  public static var _rlmType: RealmSwift.PropertyType {
    get
  }
}
extension String : RealmSwift._RealmSchemaDiscoverable {
  public static var _rlmType: RealmSwift.PropertyType {
    get
  }
}
extension Data : RealmSwift._RealmSchemaDiscoverable {
  public static var _rlmType: RealmSwift.PropertyType {
    get
  }
}
extension ObjectId : RealmSwift._RealmSchemaDiscoverable {
  public static var _rlmType: RealmSwift.PropertyType {
    get
  }
}
extension Decimal128 : RealmSwift._RealmSchemaDiscoverable {
  public static var _rlmType: RealmSwift.PropertyType {
    get
  }
}
extension Date : RealmSwift._RealmSchemaDiscoverable {
  public static var _rlmType: RealmSwift.PropertyType {
    get
  }
}
extension UUID : RealmSwift._RealmSchemaDiscoverable {
  public static var _rlmType: RealmSwift.PropertyType {
    get
  }
}
extension AnyRealmValue : RealmSwift._RealmSchemaDiscoverable {
  public static var _rlmType: RealmSwift.PropertyType {
    get
  }
}
extension NSString : RealmSwift._RealmSchemaDiscoverable {
  public static var _rlmType: RealmSwift.PropertyType {
    get
  }
}
extension NSData : RealmSwift._RealmSchemaDiscoverable {
  public static var _rlmType: RealmSwift.PropertyType {
    get
  }
}
extension NSDate : RealmSwift._RealmSchemaDiscoverable {
  public static var _rlmType: RealmSwift.PropertyType {
    get
  }
}
public protocol BSON : Swift.Equatable {
}
extension NSNull : RealmSwift.BSON {
}
extension Int : RealmSwift.BSON {
}
extension Int32 : RealmSwift.BSON {
}
extension Int64 : RealmSwift.BSON {
}
extension Bool : RealmSwift.BSON {
}
extension Double : RealmSwift.BSON {
}
extension String : RealmSwift.BSON {
}
extension Data : RealmSwift.BSON {
}
extension Date : RealmSwift.BSON {
}
extension Decimal128 : RealmSwift.BSON {
}
extension ObjectId : RealmSwift.BSON {
}
extension UUID : RealmSwift.BSON {
}
public typealias Document = Swift.Dictionary<Swift.String, RealmSwift.AnyBSON?>
extension Dictionary : RealmSwift.BSON where Key == Swift.String, Value == RealmSwift.AnyBSON? {
}
extension Array : RealmSwift.BSON where Element == RealmSwift.AnyBSON? {
}
extension NSRegularExpression : RealmSwift.BSON {
}
public typealias MaxKey = Realm.RLMMaxKey
extension RLMMaxKey : RealmSwift.BSON {
}
public typealias MinKey = Realm.RLMMinKey
extension RLMMinKey : RealmSwift.BSON {
}
@frozen public enum AnyBSON : RealmSwift.BSON {
  case double(Swift.Double)
  case string(Swift.String)
  indirect case document(RealmSwift.Document)
  indirect case array([RealmSwift.AnyBSON?])
  case binary(Foundation.Data)
  case objectId(RealmSwift.ObjectId)
  case bool(Swift.Bool)
  case datetime(Foundation.Date)
  case regex(Foundation.NSRegularExpression)
  case int32(Swift.Int32)
  case timestamp(Foundation.Date)
  case int64(Swift.Int64)
  case decimal128(RealmSwift.Decimal128)
  case uuid(Foundation.UUID)
  case minKey
  case maxKey
  case null
  public init(_ int: Swift.Int)
  public init<T>(_ bson: T) where T : RealmSwift.BSON
  public var int32Value: Swift.Int32? {
    get
  }
  public var regexValue: Foundation.NSRegularExpression? {
    get
  }
  public var int64Value: Swift.Int64? {
    get
  }
  public var objectIdValue: RealmSwift.ObjectId? {
    get
  }
  public var dateValue: Foundation.Date? {
    get
  }
  public var arrayValue: [RealmSwift.AnyBSON?]? {
    get
  }
  public var stringValue: Swift.String? {
    get
  }
  public var documentValue: RealmSwift.Document? {
    get
  }
  public var boolValue: Swift.Bool? {
    get
  }
  public var binaryValue: Foundation.Data? {
    get
  }
  public var doubleValue: Swift.Double? {
    get
  }
  public var decimal128Value: RealmSwift.Decimal128? {
    get
  }
  public var timestampValue: Foundation.Date? {
    get
  }
  public var uuidValue: Foundation.UUID? {
    get
  }
  public var isNull: Swift.Bool {
    get
  }
  public func asInt() -> Swift.Int?
  public func asInt32() -> Swift.Int32?
  public func asInt64() -> Swift.Int64?
  public func asDouble() -> Swift.Double?
  public func asDecimal128() -> RealmSwift.Decimal128?
  public func value<T>() -> T? where T : RealmSwift.BSON
}
extension AnyBSON : Swift.ExpressibleByStringLiteral {
  public init(stringLiteral value: Swift.String)
  public typealias ExtendedGraphemeClusterLiteralType = Swift.String
  public typealias StringLiteralType = Swift.String
  public typealias UnicodeScalarLiteralType = Swift.String
}
extension AnyBSON : Swift.ExpressibleByBooleanLiteral {
  public init(booleanLiteral value: Swift.Bool)
  public typealias BooleanLiteralType = Swift.Bool
}
extension AnyBSON : Swift.ExpressibleByFloatLiteral {
  public init(floatLiteral value: Swift.Double)
  public typealias FloatLiteralType = Swift.Double
}
extension AnyBSON : Swift.ExpressibleByIntegerLiteral {
  public init(integerLiteral value: Swift.Int)
  public typealias IntegerLiteralType = Swift.Int
}
extension AnyBSON : Swift.ExpressibleByDictionaryLiteral {
  public init(dictionaryLiteral elements: (Swift.String, RealmSwift.AnyBSON?)...)
  public typealias Key = Swift.String
  public typealias Value = RealmSwift.AnyBSON?
}
extension AnyBSON : Swift.ExpressibleByArrayLiteral {
  public init(arrayLiteral elements: RealmSwift.AnyBSON?...)
  public typealias ArrayLiteralElement = RealmSwift.AnyBSON?
}
extension AnyBSON : Swift.Equatable {
  public static func == (a: RealmSwift.AnyBSON, b: RealmSwift.AnyBSON) -> Swift.Bool
}
extension AnyBSON : Swift.Hashable {
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension RealmSwiftObject : RealmSwift._RealmSchemaDiscoverable {
  public static var _rlmType: RealmSwift.PropertyType {
    get
  }
  public static func _rlmPopulateProperty(_ prop: Realm.RLMProperty)
}
extension RealmSwiftEmbeddedObject : RealmSwift._RealmSchemaDiscoverable {
  public static var _rlmType: RealmSwift.PropertyType {
    get
  }
  public static func _rlmPopulateProperty(_ prop: Realm.RLMProperty)
}
extension List : RealmSwift._RealmSchemaDiscoverable {
  public static var _rlmType: RealmSwift.PropertyType {
    get
  }
  public static var _rlmOptional: Swift.Bool {
    get
  }
  public static var _rlmRequireObjc: Swift.Bool {
    get
  }
  public static func _rlmPopulateProperty(_ prop: Realm.RLMProperty)
}
extension MutableSet : RealmSwift._RealmSchemaDiscoverable {
  public static var _rlmType: RealmSwift.PropertyType {
    get
  }
  public static var _rlmOptional: Swift.Bool {
    get
  }
  public static var _rlmRequireObjc: Swift.Bool {
    get
  }
  public static func _rlmPopulateProperty(_ prop: Realm.RLMProperty)
}
extension Map : RealmSwift._RealmSchemaDiscoverable {
  public static var _rlmType: RealmSwift.PropertyType {
    get
  }
  public static var _rlmOptional: Swift.Bool {
    get
  }
  public static var _rlmRequireObjc: Swift.Bool {
    get
  }
  public static func _rlmPopulateProperty(_ prop: Realm.RLMProperty)
}
extension LinkingObjects : RealmSwift._RealmSchemaDiscoverable {
  public static var _rlmType: RealmSwift.PropertyType {
    get
  }
  public static var _rlmRequireObjc: Swift.Bool {
    get
  }
  public static func _rlmPopulateProperty(_ prop: Realm.RLMProperty)
  public func _rlmPopulateProperty(_ prop: Realm.RLMProperty)
}
@available(*, deprecated)
extension RealmOptional : RealmSwift._RealmSchemaDiscoverable where Value : RealmSwift._RealmSchemaDiscoverable {
  public static var _rlmType: RealmSwift.PropertyType {
    get
  }
  public static var _rlmOptional: Swift.Bool {
    get
  }
  public static var _rlmRequireObjc: Swift.Bool {
    get
  }
  public static func _rlmPopulateProperty(_ prop: Realm.RLMProperty)
}
extension Optional : RealmSwift._RealmSchemaDiscoverable where Wrapped : RealmSwift._RealmSchemaDiscoverable {
  public static var _rlmType: RealmSwift.PropertyType {
    get
  }
  public static var _rlmOptional: Swift.Bool {
    get
  }
  public static func _rlmPopulateProperty(_ prop: Realm.RLMProperty)
}
extension RealmProperty : RealmSwift._RealmSchemaDiscoverable where Value : RealmSwift._RealmSchemaDiscoverable {
  public static var _rlmType: RealmSwift.PropertyType {
    get
  }
  public static var _rlmOptional: Swift.Bool {
    get
  }
  public static var _rlmRequireObjc: Swift.Bool {
    get
  }
  public static func _rlmPopulateProperty(_ prop: Realm.RLMProperty)
}
@_inheritsConvenienceInitializers @objc(RealmSwiftDecimal128) final public class Decimal128 : Realm.RLMDecimal128, Swift.Decodable {
  @objc override required dynamic public init()
  @objc override required dynamic public init(value: Any)
  @objc override required dynamic public init(number: Foundation.NSNumber)
  @objc override required dynamic public init(string: Swift.String) throws
  required public init(from decoder: Swift.Decoder) throws
  public static var min: RealmSwift.Decimal128 {
    get
  }
  public static var max: RealmSwift.Decimal128 {
    get
  }
  @objc deinit
}
extension Decimal128 : Swift.Encodable {
  final public func encode(to encoder: Swift.Encoder) throws
}
extension Decimal128 : Swift.ExpressibleByIntegerLiteral {
  convenience public init(integerLiteral value: Swift.Int64)
  public typealias IntegerLiteralType = Swift.Int64
}
extension Decimal128 : Swift.ExpressibleByFloatLiteral {
  convenience public init(floatLiteral value: Swift.Double)
  public typealias FloatLiteralType = Swift.Double
}
extension Decimal128 : Swift.ExpressibleByStringLiteral {
  convenience public init(stringLiteral value: Swift.String)
  public typealias ExtendedGraphemeClusterLiteralType = Swift.String
  public typealias StringLiteralType = Swift.String
  public typealias UnicodeScalarLiteralType = Swift.String
}
extension Decimal128 : Swift.Comparable {
  public static func == (lhs: RealmSwift.Decimal128, rhs: RealmSwift.Decimal128) -> Swift.Bool
  public static func < (lhs: RealmSwift.Decimal128, rhs: RealmSwift.Decimal128) -> Swift.Bool
  public static func <= (lhs: RealmSwift.Decimal128, rhs: RealmSwift.Decimal128) -> Swift.Bool
  public static func >= (lhs: RealmSwift.Decimal128, rhs: RealmSwift.Decimal128) -> Swift.Bool
  public static func > (lhs: RealmSwift.Decimal128, rhs: RealmSwift.Decimal128) -> Swift.Bool
}
extension Decimal128 {
  convenience public init?<T>(exactly source: T) where T : Swift.BinaryInteger
  public typealias Magnitude = RealmSwift.Decimal128
  final public var magnitude: RealmSwift.Decimal128.Magnitude {
    get
  }
  public static func + (lhs: RealmSwift.Decimal128, rhs: RealmSwift.Decimal128) -> RealmSwift.Decimal128
  public static func - (lhs: RealmSwift.Decimal128, rhs: RealmSwift.Decimal128) -> RealmSwift.Decimal128
  public static func * (lhs: RealmSwift.Decimal128, rhs: RealmSwift.Decimal128) -> RealmSwift.Decimal128
  public static func / (lhs: RealmSwift.Decimal128, rhs: RealmSwift.Decimal128) -> RealmSwift.Decimal128
}
extension Decimal128 {
  public typealias Stride = RealmSwift.Decimal128
  final public func distance(to other: RealmSwift.Decimal128) -> RealmSwift.Decimal128.Stride
  final public func advanced(by n: RealmSwift.Decimal128) -> RealmSwift.Decimal128
}
extension Decimal128 {
  final public var isSignaling: Swift.Bool {
    get
  }
  final public var isSignalingNaN: Swift.Bool {
    get
  }
}
public typealias EmbeddedObject = Realm.RealmSwiftEmbeddedObject
extension RealmSwiftEmbeddedObject : RealmSwift.RealmCollectionValue {
  @objc override final public class func isEmbedded() -> Swift.Bool
  convenience public init(value: Any)
  public var realm: RealmSwift.Realm? {
    get
  }
  public var objectSchema: RealmSwift.ObjectSchema {
    get
  }
  @objc override final public var isInvalidated: Swift.Bool {
    @objc get
  }
  @objc override dynamic open var description: Swift.String {
    @objc get
  }
  @objc override final public class func _getProperties() -> [Realm.RLMProperty]
  @objc dynamic open class func ignoredProperties() -> [Swift.String]
  @objc dynamic open subscript(key: Swift.String) -> Any? {
    @objc get
    @objc set
  }
  public func observe<T>(on queue: Dispatch.DispatchQueue? = nil, _ block: @escaping (RealmSwift.ObjectChange<T>) -> Swift.Void) -> RealmSwift.NotificationToken where T : RealmSwift.ObjectBase
  public func dynamicList(_ propertyName: Swift.String) -> RealmSwift.List<RealmSwift.DynamicObject>
  public func isSameObject(as object: RealmSwift.EmbeddedObject?) -> Swift.Bool
}
extension RealmSwiftEmbeddedObject : RealmSwift.ThreadConfined {
  public var isFrozen: Swift.Bool {
    get
  }
  public func freeze() -> Self
  public func thaw() -> Self?
}
extension Realm {
  @frozen public struct Error {
    public typealias Code = Realm.RLMError.Code
    public static let fail: RealmSwift.Realm.Error.Code
    public static let fileAccess: RealmSwift.Realm.Error.Code
    public static let filePermissionDenied: RealmSwift.Realm.Error.Code
    public static let fileExists: RealmSwift.Realm.Error.Code
    public static let fileNotFound: RealmSwift.Realm.Error.Code
    public static let incompatibleLockFile: RealmSwift.Realm.Error.Code
    public static let fileFormatUpgradeRequired: RealmSwift.Realm.Error.Code
    public static let addressSpaceExhausted: RealmSwift.Realm.Error.Code
    public static let schemaMismatch: RealmSwift.Realm.Error.Code
    public var code: RealmSwift.Realm.Error.Code {
      get
    }
    public let _nsError: Foundation.NSError
    public init(_nsError error: Foundation.NSError)
    public var backupConfiguration: RealmSwift.Realm.Configuration? {
      get
    }
    public static let callFailed: RealmSwift.Realm.Error
  }
}
extension Realm.Error : Foundation._BridgedStoredNSError {
  public static let _nsErrorDomain: Swift.String
  public static let errorDomain: Swift.String
}
extension Realm.Error : Swift.Equatable {
}
public func == (lhs: Swift.Error, rhs: Swift.Error) -> Swift.Bool
public func ~= (lhs: RealmSwift.Realm.Error, rhs: Swift.Error) -> Swift.Bool
@frozen public struct LinkingObjects<Element> where Element : RealmSwift.ObjectBase, Element : RealmSwift.RealmCollectionValue {
  public typealias ElementType = Element
  public var realm: RealmSwift.Realm? {
    get
  }
  public var isInvalidated: Swift.Bool {
    get
  }
  public var count: Swift.Int {
    get
  }
  public init(fromType _: Element.Type, property propertyName: Swift.String)
  public var description: Swift.String {
    get
  }
  public func index(of object: Element) -> Swift.Int?
  public func index(matching predicate: Foundation.NSPredicate) -> Swift.Int?
  public subscript(index: Swift.Int) -> Element {
    get
  }
  public var first: Element? {
    get
  }
  public var last: Element? {
    get
  }
  public func value(forKey key: Swift.String) -> Any?
  public func value(forKeyPath keyPath: Swift.String) -> Any?
  public func setValue(_ value: Any?, forKey key: Swift.String)
  public func filter(_ predicate: Foundation.NSPredicate) -> RealmSwift.Results<Element>
  public func sorted(byKeyPath keyPath: Swift.String, ascending: Swift.Bool = true) -> RealmSwift.Results<Element>
  public func sorted<S>(by sortDescriptors: S) -> RealmSwift.Results<Element> where S : Swift.Sequence, S.Element == RealmSwift.SortDescriptor
  public func min<T>(ofProperty property: Swift.String) -> T? where T : RealmSwift.MinMaxType
  public func max<T>(ofProperty property: Swift.String) -> T? where T : RealmSwift.MinMaxType
  public func sum<T>(ofProperty property: Swift.String) -> T where T : RealmSwift.AddableType
  public func average<T>(ofProperty property: Swift.String) -> T? where T : RealmSwift.AddableType
  public func observe(on queue: Dispatch.DispatchQueue? = nil, _ block: @escaping (RealmSwift.RealmCollectionChange<RealmSwift.LinkingObjects<Element>>) -> Swift.Void) -> RealmSwift.NotificationToken
  public var isFrozen: Swift.Bool {
    get
  }
  public func freeze() -> RealmSwift.LinkingObjects<Element>
  public func thaw() -> RealmSwift.LinkingObjects<Element>?
  internal var propertyName: Swift.String
  internal var handle: Realm.RLMLinkingObjectsHandle?
}
extension LinkingObjects : RealmSwift.RealmCollection {
  public func makeIterator() -> RealmSwift.RLMIterator<Element>
  public var startIndex: Swift.Int {
    get
  }
  public var endIndex: Swift.Int {
    get
  }
  public func index(after: Swift.Int) -> Swift.Int
  public func index(before: Swift.Int) -> Swift.Int
  public func _observe(_ queue: Dispatch.DispatchQueue?, _ block: @escaping (RealmSwift.RealmCollectionChange<RealmSwift.AnyRealmCollection<Element>>) -> Swift.Void) -> RealmSwift.NotificationToken
  public typealias Elements = RealmSwift.LinkingObjects<Element>
  public typealias Index = Swift.Int
  public typealias Indices = Swift.Range<Swift.Int>
  public typealias Iterator = RealmSwift.RLMIterator<Element>
  public typealias SubSequence = Swift.Slice<RealmSwift.LinkingObjects<Element>>
}
@_hasMissingDesignatedInitializers final public class List<Element> : Realm.RLMSwiftCollectionBase where Element : RealmSwift.RealmCollectionValue {
  final public var realm: RealmSwift.Realm? {
    get
  }
  final public var isInvalidated: Swift.Bool {
    get
  }
  @objc override dynamic public init()
  final public var count: Swift.Int {
    get
  }
  final public func index(of object: Element) -> Swift.Int?
  final public func index(matching predicate: Foundation.NSPredicate) -> Swift.Int?
  final public subscript(position: Swift.Int) -> Element {
    get
    set
  }
  final public var first: Element? {
    get
  }
  final public var last: Element? {
    get
  }
  @nonobjc final public func value(forKey key: Swift.String) -> [Swift.AnyObject]
  @nonobjc final public func value(forKeyPath keyPath: Swift.String) -> [Swift.AnyObject]
  @objc override final public func setValue(_ value: Any?, forKey key: Swift.String)
  final public func filter(_ predicate: Foundation.NSPredicate) -> RealmSwift.Results<Element>
  final public func sorted(byKeyPath keyPath: Swift.String, ascending: Swift.Bool = true) -> RealmSwift.Results<Element>
  final public func sorted<S>(by sortDescriptors: S) -> RealmSwift.Results<Element> where S : Swift.Sequence, S.Element == RealmSwift.SortDescriptor
  final public func min<T>(ofProperty property: Swift.String) -> T? where T : RealmSwift.MinMaxType
  final public func max<T>(ofProperty property: Swift.String) -> T? where T : RealmSwift.MinMaxType
  final public func sum<T>(ofProperty property: Swift.String) -> T where T : RealmSwift.AddableType
  final public func average<T>(ofProperty property: Swift.String) -> T? where T : RealmSwift.AddableType
  final public func append(_ object: Element)
  final public func append<S>(objectsIn objects: S) where Element == S.Element, S : Swift.Sequence
  final public func insert(_ object: Element, at index: Swift.Int)
  final public func remove(at index: Swift.Int)
  final public func removeAll()
  final public func replace(index: Swift.Int, object: Element)
  final public func move(from: Swift.Int, to: Swift.Int)
  final public func swapAt(_ index1: Swift.Int, _ index2: Swift.Int)
  final public func observe(on queue: Dispatch.DispatchQueue? = nil, _ block: @escaping (RealmSwift.RealmCollectionChange<RealmSwift.List<Element>>) -> Swift.Void) -> RealmSwift.NotificationToken
  final public var isFrozen: Swift.Bool {
    get
  }
  final public func freeze() -> RealmSwift.List<Element>
  final public func thaw() -> RealmSwift.List<Element>?
  @objc override final public class func _backingCollectionType() -> Swift.AnyClass
  @objc override final public var description: Swift.String {
    @objc get
  }
  @objc override dynamic public init(collection: Realm.RLMCollection)
  @objc deinit
}
extension List where Element : RealmSwift.MinMaxType {
  final public func min() -> Element?
  final public func max() -> Element?
}
extension List where Element : RealmSwift.AddableType {
  final public func sum() -> Element
  final public func average<T>() -> T? where T : RealmSwift.AddableType
}
extension List : RealmSwift.RealmCollection {
  public typealias ElementType = Element
  final public func makeIterator() -> RealmSwift.RLMIterator<Element>
  final public func replaceSubrange<C, R>(_ subrange: R, with newElements: C) where Element == C.Element, C : Swift.Collection, R : Swift.RangeExpression, R.Bound == Swift.Int
  final public var startIndex: Swift.Int {
    get
  }
  final public var endIndex: Swift.Int {
    get
  }
  final public func index(after i: Swift.Int) -> Swift.Int
  final public func index(before i: Swift.Int) -> Swift.Int
  final public func _observe(_ queue: Dispatch.DispatchQueue?, _ block: @escaping (RealmSwift.RealmCollectionChange<RealmSwift.AnyRealmCollection<Element>>) -> Swift.Void) -> RealmSwift.NotificationToken
  public typealias Elements = RealmSwift.List<Element>
  public typealias Index = Swift.Int
  public typealias Indices = Swift.Range<Swift.Int>
  public typealias Iterator = RealmSwift.RLMIterator<Element>
}
extension List : Swift.MutableCollection {
  public typealias SubSequence = Swift.Slice<RealmSwift.List<Element>>
  final public subscript(bounds: Swift.Range<Swift.Int>) -> RealmSwift.List<Element>.SubSequence {
    get
    set
  }
  final public func removeFirst(_ number: Swift.Int = 1)
  final public func removeLast(_ number: Swift.Int = 1)
  final public func insert<C>(contentsOf newElements: C, at i: Swift.Int) where Element == C.Element, C : Swift.Collection
  final public func removeSubrange<R>(_ boundsExpression: R) where R : Swift.RangeExpression, R.Bound == Swift.Int
  final public func remove(atOffsets offsets: Foundation.IndexSet)
  final public func move(fromOffsets offsets: Foundation.IndexSet, toOffset destination: Swift.Int)
}
extension List : Swift.Decodable where Element : Swift.Decodable {
  convenience public init(from decoder: Swift.Decoder) throws
}
extension List : Swift.Encodable where Element : Swift.Encodable {
  final public func encode(to encoder: Swift.Encoder) throws
}
public protocol _MapKey : Swift.Hashable {
  static var _rlmType: Realm.RLMPropertyType { get }
}
extension String : RealmSwift._MapKey {
}
@_hasMissingDesignatedInitializers final public class Map<Key, Value> : Realm.RLMSwiftCollectionBase where Key : RealmSwift._MapKey, Value : RealmSwift.RealmCollectionValue {
  final public var realm: RealmSwift.Realm? {
    get
  }
  final public var isInvalidated: Swift.Bool {
    get
  }
  final public var keys: [Key] {
    get
  }
  final public var values: [Value] {
    get
  }
  @objc override dynamic public init()
  @objc final public var count: Swift.Int {
    @objc get
  }
  final public func updateValue(_ value: Value, forKey key: Key)
  final public func removeObject(for key: Key)
  final public func removeAll()
  final public subscript(key: Key) -> Value? {
    get
    set
  }
  @objc final public func object(forKey key: Swift.AnyObject) -> Swift.AnyObject?
  @nonobjc final public func value(forKey key: Swift.String) -> Swift.AnyObject?
  @nonobjc final public func value(forKeyPath keyPath: Swift.String) -> Swift.AnyObject?
  @objc override final public func setValue(_ value: Any?, forKey key: Swift.String)
  final public func filter(_ predicate: Foundation.NSPredicate) -> RealmSwift.Results<Value>
  final public func contains(where predicate: @escaping (Key, Value) -> Swift.Bool) -> Swift.Bool
  final public func sorted(ascending: Swift.Bool = true) -> RealmSwift.Results<Value>
  final public func sorted(byKeyPath keyPath: Swift.String, ascending: Swift.Bool = true) -> RealmSwift.Results<Value>
  final public func sorted<S>(by sortDescriptors: S) -> RealmSwift.Results<Value> where S : Swift.Sequence, S.Element == RealmSwift.SortDescriptor
  final public func min<T>(ofProperty property: Swift.String) -> T? where T : RealmSwift.MinMaxType
  final public func max<T>(ofProperty property: Swift.String) -> T? where T : RealmSwift.MinMaxType
  final public func sum<T>(ofProperty property: Swift.String) -> T where T : RealmSwift.AddableType
  final public func average<T>(ofProperty property: Swift.String) -> T? where T : RealmSwift.AddableType
  final public func observe(on queue: Dispatch.DispatchQueue?, _ block: @escaping (RealmSwift.RealmMapChange<RealmSwift.Map<Key, Value>>) -> Swift.Void) -> RealmSwift.NotificationToken
  final public var isFrozen: Swift.Bool {
    get
  }
  final public func freeze() -> RealmSwift.Map<Key, Value>
  final public func thaw() -> RealmSwift.Map<Key, Value>?
  @objc override final public class func _backingCollectionType() -> Swift.AnyClass
  @objc override final public var description: Swift.String {
    @objc get
  }
  @objc override dynamic public init(collection: Realm.RLMCollection)
  @objc deinit
}
extension Map where Value : RealmSwift.MinMaxType {
  final public func min() -> Value?
  final public func max() -> Value?
}
extension Map where Value : RealmSwift.OptionalProtocol, Value.Wrapped : RealmSwift.MinMaxType {
  final public func min() -> Value.Wrapped?
  final public func max() -> Value.Wrapped?
}
extension Map where Value : RealmSwift.AddableType {
  final public func sum() -> Value
  final public func average<T>() -> T? where T : RealmSwift.AddableType
}
extension Map where Value : RealmSwift.OptionalProtocol, Value.Wrapped : RealmSwift.AddableType {
  final public func sum() -> Value.Wrapped
  final public func average<T>() -> T? where T : RealmSwift.AddableType
}
extension Map : Swift.Sequence {
  final public func makeIterator() -> RealmSwift.RLMMapIterator<RealmSwift.SingleMapEntry<Key, Value>>
  public typealias Element = RealmSwift.SingleMapEntry<Key, Value>
  public typealias Iterator = RealmSwift.RLMMapIterator<RealmSwift.SingleMapEntry<Key, Value>>
}
@frozen public enum RealmMapChange<Collection> where Collection : RealmSwift.RealmKeyedCollection {
  case initial(Collection)
  case update(Collection, deletions: [Collection.Key], insertions: [Collection.Key], modifications: [Collection.Key])
  case error(Swift.Error)
}
extension Map : RealmSwift.RealmKeyedCollection {
}
public struct MapIndex {
  public var offset: Swift.UInt
}
public struct SingleMapEntry<Key, Value> : RealmSwift._RealmMapValue, Swift.Hashable where Key : RealmSwift._MapKey, Value : RealmSwift.RealmCollectionValue {
  public static func == (lhs: RealmSwift.SingleMapEntry<Key, Value>, rhs: RealmSwift.SingleMapEntry<Key, Value>) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var key: RealmSwift.SingleMapEntry<Key, Value>.Key
  public var value: RealmSwift.SingleMapEntry<Key, Value>.Value
  public var hashValue: Swift.Int {
    get
  }
}
public typealias MigrationBlock = (RealmSwift.Migration, Swift.UInt64) -> Swift.Void
public typealias MigrationObject = RealmSwift.DynamicObject
public typealias MigrationObjectEnumerateBlock = (RealmSwift.MigrationObject?, RealmSwift.MigrationObject?) -> Swift.Void
public func schemaVersionAtURL(_ fileURL: Foundation.URL, encryptionKey: Foundation.Data? = nil) throws -> Swift.UInt64
extension Realm {
  public static func performMigration(for configuration: RealmSwift.Realm.Configuration = Realm.Configuration.defaultConfiguration) throws
}
@frozen public struct Migration {
  public var oldSchema: RealmSwift.Schema {
    get
  }
  public var newSchema: RealmSwift.Schema {
    get
  }
  internal var rlmMigration: Realm.RLMMigration
  public func enumerateObjects(ofType typeName: Swift.String, _ block: (RealmSwift.MigrationObject?, RealmSwift.MigrationObject?) -> Swift.Void)
  @discardableResult
  public func create(_ typeName: Swift.String, value: Any = [:]) -> RealmSwift.MigrationObject
  public func delete(_ object: RealmSwift.MigrationObject)
  @discardableResult
  public func deleteData(forType typeName: Swift.String) -> Swift.Bool
  public func renameProperty(onType typeName: Swift.String, from oldName: Swift.String, to newName: Swift.String)
}
public typealias MongoClient = Realm.RLMMongoClient
public typealias MongoDatabase = Realm.RLMMongoDatabase
public typealias FindOptions = Realm.RLMFindOptions
extension RLMFindOptions {
  public var projection: RealmSwift.Document? {
    get
    set
  }
  public var sort: RealmSwift.Document? {
    get
    set
  }
  convenience public init(_ limit: Swift.Int?, _ projection: RealmSwift.Document?, _ sort: RealmSwift.Document?)
  convenience public init(limit: Swift.Int?, projection: RealmSwift.Document?, sort: RealmSwift.Document?)
}
public typealias FindOneAndModifyOptions = Realm.RLMFindOneAndModifyOptions
extension RLMFindOneAndModifyOptions {
  public var projection: RealmSwift.Document? {
    get
    set
  }
  public var sort: RealmSwift.Document? {
    get
    set
  }
  convenience public init(_ projection: RealmSwift.Document?, _ sort: RealmSwift.Document?, _ upsert: Swift.Bool = false, _ shouldReturnNewDocument: Swift.Bool = false)
  convenience public init(projection: RealmSwift.Document?, sort: RealmSwift.Document?, upsert: Swift.Bool = false, shouldReturnNewDocument: Swift.Bool = false)
}
public typealias UpdateResult = Realm.RLMUpdateResult
public typealias MongoInsertBlock = (Swift.Result<RealmSwift.AnyBSON, Swift.Error>) -> Swift.Void
public typealias MongoInsertManyBlock = (Swift.Result<[RealmSwift.AnyBSON], Swift.Error>) -> Swift.Void
public typealias MongoFindBlock = (Swift.Result<[RealmSwift.Document], Swift.Error>) -> Swift.Void
public typealias MongoFindOneBlock = (Swift.Result<RealmSwift.Document?, Swift.Error>) -> Swift.Void
public typealias MongoCountBlock = (Swift.Result<Swift.Int, Swift.Error>) -> Swift.Void
public typealias MongoUpdateBlock = (Swift.Result<RealmSwift.UpdateResult, Swift.Error>) -> Swift.Void
public typealias MongoCollection = Realm.RLMMongoCollection
public typealias ChangeStream = Realm.RLMChangeStream
public protocol ChangeEventDelegate : AnyObject {
  func changeStreamDidOpen(_ changeStream: RealmSwift.ChangeStream)
  func changeStreamDidClose(with error: Swift.Error?)
  func changeStreamDidReceive(error: Swift.Error)
  func changeStreamDidReceive(changeEvent: RealmSwift.AnyBSON?)
}
extension RLMMongoCollection {
  public func watch(delegate: RealmSwift.ChangeEventDelegate, queue: Dispatch.DispatchQueue = .main) -> RealmSwift.ChangeStream
  public func watch(matchFilter: RealmSwift.Document, delegate: RealmSwift.ChangeEventDelegate, queue: Dispatch.DispatchQueue = .main) -> RealmSwift.ChangeStream
  public func watch(filterIds: [RealmSwift.ObjectId], delegate: RealmSwift.ChangeEventDelegate, queue: Dispatch.DispatchQueue = .main) -> RealmSwift.ChangeStream
}
extension RLMMongoCollection {
  public func insertOne(_ document: RealmSwift.Document, _ completion: @escaping RealmSwift.MongoInsertBlock)
  public func insertMany(_ documents: [RealmSwift.Document], _ completion: @escaping RealmSwift.MongoInsertManyBlock)
  public func find(filter: RealmSwift.Document, options: RealmSwift.FindOptions, _ completion: @escaping RealmSwift.MongoFindBlock)
  public func find(filter: RealmSwift.Document, _ completion: @escaping RealmSwift.MongoFindBlock)
  public func findOneDocument(filter: RealmSwift.Document, options: RealmSwift.FindOptions, _ completion: @escaping RealmSwift.MongoFindOneBlock)
  public func findOneDocument(filter: RealmSwift.Document, _ completion: @escaping RealmSwift.MongoFindOneBlock)
  public func aggregate(pipeline: [RealmSwift.Document], _ completion: @escaping RealmSwift.MongoFindBlock)
  public func count(filter: RealmSwift.Document, limit: Swift.Int, _ completion: @escaping RealmSwift.MongoCountBlock)
  public func count(filter: RealmSwift.Document, _ completion: @escaping RealmSwift.MongoCountBlock)
  public func deleteOneDocument(filter: RealmSwift.Document, _ completion: @escaping RealmSwift.MongoCountBlock)
  public func deleteManyDocuments(filter: RealmSwift.Document, _ completion: @escaping RealmSwift.MongoCountBlock)
  public func updateOneDocument(filter: RealmSwift.Document, update: RealmSwift.Document, upsert: Swift.Bool, _ completion: @escaping RealmSwift.MongoUpdateBlock)
  public func updateOneDocument(filter: RealmSwift.Document, update: RealmSwift.Document, _ completion: @escaping RealmSwift.MongoUpdateBlock)
  public func updateManyDocuments(filter: RealmSwift.Document, update: RealmSwift.Document, upsert: Swift.Bool, _ completion: @escaping RealmSwift.MongoUpdateBlock)
  public func updateManyDocuments(filter: RealmSwift.Document, update: RealmSwift.Document, _ completion: @escaping RealmSwift.MongoUpdateBlock)
  public func findOneAndUpdate(filter: RealmSwift.Document, update: RealmSwift.Document, options: RealmSwift.FindOneAndModifyOptions, _ completion: @escaping RealmSwift.MongoFindOneBlock)
  public func findOneAndUpdate(filter: RealmSwift.Document, update: RealmSwift.Document, _ completion: @escaping RealmSwift.MongoFindOneBlock)
  public func findOneAndReplace(filter: RealmSwift.Document, replacement: RealmSwift.Document, options: RealmSwift.FindOneAndModifyOptions, _ completion: @escaping RealmSwift.MongoFindOneBlock)
  public func findOneAndReplace(filter: RealmSwift.Document, replacement: RealmSwift.Document, _ completion: @escaping RealmSwift.MongoFindOneBlock)
  public func findOneAndDelete(filter: RealmSwift.Document, options: RealmSwift.FindOneAndModifyOptions, _ completion: @escaping RealmSwift.MongoFindOneBlock)
  public func findOneAndDelete(filter: RealmSwift.Document, _ completion: @escaping RealmSwift.MongoFindOneBlock)
}
@_hasMissingDesignatedInitializers final public class MutableSet<Element> : Realm.RLMSwiftCollectionBase where Element : RealmSwift.RealmCollectionValue {
  final public var realm: RealmSwift.Realm? {
    get
  }
  final public var isInvalidated: Swift.Bool {
    get
  }
  @objc override dynamic public init()
  final public var count: Swift.Int {
    get
  }
  @nonobjc final public func value(forKey key: Swift.String) -> [Swift.AnyObject]
  @nonobjc final public func value(forKeyPath keyPath: Swift.String) -> [Swift.AnyObject]
  @objc override final public func setValue(_ value: Any?, forKey key: Swift.String)
  final public func filter(_ predicate: Foundation.NSPredicate) -> RealmSwift.Results<Element>
  final public func contains(_ object: Element) -> Swift.Bool
  final public func isSubset(of possibleSuperset: RealmSwift.MutableSet<Element>) -> Swift.Bool
  final public func intersects(_ otherSet: RealmSwift.MutableSet<Element>) -> Swift.Bool
  final public func sorted(byKeyPath keyPath: Swift.String, ascending: Swift.Bool = true) -> RealmSwift.Results<Element>
  final public func sorted<S>(by sortDescriptors: S) -> RealmSwift.Results<Element> where S : Swift.Sequence, S.Element == RealmSwift.SortDescriptor
  final public func min<T>(ofProperty property: Swift.String) -> T? where T : RealmSwift.MinMaxType
  final public func max<T>(ofProperty property: Swift.String) -> T? where T : RealmSwift.MinMaxType
  final public func sum<T>(ofProperty property: Swift.String) -> T where T : RealmSwift.AddableType
  final public func average<T>(ofProperty property: Swift.String) -> T? where T : RealmSwift.AddableType
  final public func insert(_ object: Element)
  final public func insert<S>(objectsIn objects: S) where Element == S.Element, S : Swift.Sequence
  final public func remove(_ object: Element)
  final public func removeAll()
  final public func formIntersection(_ other: RealmSwift.MutableSet<Element>)
  final public func subtract(_ other: RealmSwift.MutableSet<Element>)
  final public func formUnion(_ other: RealmSwift.MutableSet<Element>)
  final public func observe(on queue: Dispatch.DispatchQueue? = nil, _ block: @escaping (RealmSwift.RealmCollectionChange<RealmSwift.MutableSet<Element>>) -> Swift.Void) -> RealmSwift.NotificationToken
  final public var isFrozen: Swift.Bool {
    get
  }
  final public func freeze() -> RealmSwift.MutableSet<Element>
  final public func thaw() -> RealmSwift.MutableSet<Element>?
  @objc override final public class func _backingCollectionType() -> Swift.AnyClass
  @objc override final public var description: Swift.String {
    @objc get
  }
  @objc override dynamic public init(collection: Realm.RLMCollection)
  @objc deinit
}
extension MutableSet where Element : RealmSwift.MinMaxType {
  final public func min() -> Element?
  final public func max() -> Element?
}
extension MutableSet where Element : RealmSwift.AddableType {
  final public func sum() -> Element
  final public func average<T>() -> T? where T : RealmSwift.AddableType
}
extension MutableSet : RealmSwift.RealmCollection {
  public typealias ElementType = Element
  final public func makeIterator() -> RealmSwift.RLMIterator<Element>
  final public var startIndex: Swift.Int {
    get
  }
  final public var endIndex: Swift.Int {
    get
  }
  final public func index(after i: Swift.Int) -> Swift.Int
  final public func index(before i: Swift.Int) -> Swift.Int
  final public func _observe(_ queue: Dispatch.DispatchQueue?, _ block: @escaping (RealmSwift.RealmCollectionChange<RealmSwift.AnyRealmCollection<Element>>) -> Swift.Void) -> RealmSwift.NotificationToken
  final public subscript(position: Swift.Int) -> Element {
    get
  }
  final public func index(of object: Element) -> Swift.Int?
  final public func index(matching predicate: Foundation.NSPredicate) -> Swift.Int?
  final public var first: Element? {
    get
  }
  public typealias Elements = RealmSwift.MutableSet<Element>
  public typealias Index = Swift.Int
  public typealias Indices = Swift.Range<Swift.Int>
  public typealias Iterator = RealmSwift.RLMIterator<Element>
  public typealias SubSequence = Swift.Slice<RealmSwift.MutableSet<Element>>
}
extension MutableSet : Swift.Decodable where Element : Swift.Decodable {
  convenience public init(from decoder: Swift.Decoder) throws
}
extension MutableSet : Swift.Encodable where Element : Swift.Encodable {
  final public func encode(to encoder: Swift.Encoder) throws
}
public typealias Object = Realm.RealmSwiftObject
extension RealmSwiftObject : RealmSwift.RealmCollectionValue {
  convenience public init(value: Any)
  public var realm: RealmSwift.Realm? {
    get
  }
  public var objectSchema: RealmSwift.ObjectSchema {
    get
  }
  @objc dynamic override open var isInvalidated: Swift.Bool {
    @objc get
  }
  @objc override dynamic open var description: Swift.String {
    @objc get
  }
  @objc override final public class func _getProperties() -> [Realm.RLMProperty]
  @objc dynamic open class func primaryKey() -> Swift.String?
  @objc dynamic open class func ignoredProperties() -> [Swift.String]
  @objc dynamic open class func indexedProperties() -> [Swift.String]
  @objc dynamic open subscript(key: Swift.String) -> Any? {
    @objc get
    @objc set
  }
  public func observe<T>(on queue: Dispatch.DispatchQueue? = nil, _ block: @escaping (RealmSwift.ObjectChange<T>) -> Swift.Void) -> RealmSwift.NotificationToken where T : RealmSwift.ObjectBase
  public func dynamicList(_ propertyName: Swift.String) -> RealmSwift.List<RealmSwift.DynamicObject>
  public func dynamicMutableSet(_ propertyName: Swift.String) -> RealmSwift.MutableSet<RealmSwift.DynamicObject>
  public func dynamicMap<Key>(_ propertyName: Swift.String) -> RealmSwift.Map<Key, RealmSwift.DynamicObject> where Key : RealmSwift._MapKey
  public func isSameObject(as object: RealmSwift.Object?) -> Swift.Bool
}
extension RealmSwiftObject : RealmSwift.ThreadConfined {
  public var isFrozen: Swift.Bool {
    get
  }
  public func freeze() -> Self
  public func thaw() -> Self?
}
@frozen public struct PropertyChange {
  public let name: Swift.String
  public let oldValue: Any?
  public let newValue: Any?
}
@frozen public enum ObjectChange<T> where T : RealmSwift.ObjectBase {
  case error(_: Foundation.NSError)
  case change(T, [RealmSwift.PropertyChange])
  case deleted
}
@_inheritsConvenienceInitializers @objc(RealmSwiftDynamicObject) @dynamicMemberLookup final public class DynamicObject : RealmSwift.Object {
  @objc override final public subscript(key: Swift.String) -> Any? {
    @objc get
    @objc set(value)
  }
  final public subscript(dynamicMember member: Swift.String) -> Any? {
    get
    set(value)
  }
  @objc override final public func value(forUndefinedKey key: Swift.String) -> Any?
  @objc override final public func setValue(_ value: Any?, forUndefinedKey key: Swift.String)
  @objc override final public class func shouldIncludeInDefaultSchema() -> Swift.Bool
  @objc override final public class func sharedSchema() -> Realm.RLMObjectSchema?
  @objc override dynamic public init()
  @objc deinit
}
public protocol RealmEnum : RealmSwift.RealmOptionalType, RealmSwift._RealmSchemaDiscoverable {
  static func _rlmToRawValue(_ value: Any) -> Any
  static func _rlmFromRawValue(_ value: Any) -> Any
}
extension RealmEnum where Self : Swift.RawRepresentable, Self.RawValue : RealmSwift._RealmSchemaDiscoverable {
  public static func _rlmToRawValue(_ value: Any) -> Any
  public static func _rlmFromRawValue(_ value: Any) -> Any
  public static func _rlmPopulateProperty(_ prop: Realm.RLMProperty)
  public static var _rlmType: RealmSwift.PropertyType {
    get
  }
}
@objc(RealmSwiftObjectId) final public class ObjectId : Realm.RLMObjectId, Swift.Decodable {
  @objc override required dynamic public init()
  @objc override final public class func generate() -> RealmSwift.ObjectId
  @objc override required dynamic public init(string: Swift.String) throws
  required public init(timestamp: Foundation.Date, machineId: Swift.Int, processId: Swift.Int)
  required public init(_ str: Swift.StaticString)
  required public init(from decoder: Swift.Decoder) throws
  @objc override dynamic public init(timestamp: Foundation.Date, machineIdentifier: Swift.Int32, processIdentifier: Swift.Int32)
  @objc deinit
}
extension ObjectId : Swift.Encodable {
  final public func encode(to encoder: Swift.Encoder) throws
}
extension ObjectId : Swift.Comparable {
  public static func < (lhs: RealmSwift.ObjectId, rhs: RealmSwift.ObjectId) -> Swift.Bool
  public static func <= (lhs: RealmSwift.ObjectId, rhs: RealmSwift.ObjectId) -> Swift.Bool
  public static func >= (lhs: RealmSwift.ObjectId, rhs: RealmSwift.ObjectId) -> Swift.Bool
  public static func > (lhs: RealmSwift.ObjectId, rhs: RealmSwift.ObjectId) -> Swift.Bool
}
extension ObjectiveCSupport {
  public static func convert(value: RealmSwift.AnyRealmValue?) -> Realm.RLMValue?
  public static func convert(value: Realm.RLMValue?) -> RealmSwift.AnyRealmValue
}
extension ObjectiveCSupport {
  public static func convert(object: RealmSwift.AnyBSON?) -> Realm.RLMBSON?
  public static func convert(object: Realm.RLMBSON?) -> RealmSwift.AnyBSON?
  public static func convertBson(object: RealmSwift.AnyBSON) -> Realm.RLMBSON
  public static func convertBson(object bson: Realm.RLMBSON) -> RealmSwift.AnyBSON?
}
extension ObjectiveCSupport {
  public static func convert(object: RealmSwift.SyncConfiguration) -> Realm.RLMSyncConfiguration
  public static func convert(object: Realm.RLMSyncConfiguration) -> RealmSwift.SyncConfiguration
  public static func convert(object: RealmSwift.Credentials) -> Realm.RLMCredentials
}
@frozen public struct ObjectiveCSupport {
  public static func convert<T>(object: RealmSwift.Results<T>) -> Realm.RLMResults<Swift.AnyObject> where T : RealmSwift.RealmCollectionValue
  public static func convert(object: Realm.RLMResults<Swift.AnyObject>) -> RealmSwift.Results<RealmSwift.Object>
  public static func convert<T>(object: RealmSwift.List<T>) -> Realm.RLMArray<Swift.AnyObject> where T : RealmSwift.RealmCollectionValue
  public static func convert<T>(object: RealmSwift.MutableSet<T>) -> Realm.RLMSet<Swift.AnyObject> where T : RealmSwift.RealmCollectionValue
  public static func convert(object: Realm.RLMArray<Swift.AnyObject>) -> RealmSwift.List<RealmSwift.Object>
  public static func convert(object: Realm.RLMSet<Swift.AnyObject>) -> RealmSwift.MutableSet<RealmSwift.Object>
  public static func convert<Key, Value>(object: RealmSwift.Map<Key, Value>) -> Realm.RLMDictionary<Swift.AnyObject, Swift.AnyObject> where Key : RealmSwift._MapKey, Value : RealmSwift.RealmCollectionValue
  public static func convert<Key>(object: Realm.RLMDictionary<Swift.AnyObject, Swift.AnyObject>) -> RealmSwift.Map<Key, RealmSwift.Object> where Key : RealmSwift._MapKey
  public static func convert<T>(object: RealmSwift.LinkingObjects<T>) -> Realm.RLMResults<Swift.AnyObject> where T : RealmSwift.ObjectBase, T : RealmSwift.RealmCollectionValue
  public static func convert(object: Realm.RLMLinkingObjects<Realm.RLMObject>) -> RealmSwift.Results<RealmSwift.Object>
  public static func convert(object: RealmSwift.Realm) -> Realm.RLMRealm
  public static func convert(object: Realm.RLMRealm) -> RealmSwift.Realm
  public static func convert(object: RealmSwift.Migration) -> Realm.RLMMigration
  public static func convert(object: Realm.RLMMigration) -> RealmSwift.Migration
  public static func convert(object: RealmSwift.ObjectSchema) -> Realm.RLMObjectSchema
  public static func convert(object: Realm.RLMObjectSchema) -> RealmSwift.ObjectSchema
  public static func convert(object: RealmSwift.Property) -> Realm.RLMProperty
  public static func convert(object: Realm.RLMProperty) -> RealmSwift.Property
  public static func convert(object: RealmSwift.Realm.Configuration) -> Realm.RLMRealmConfiguration
  public static func convert(object: Realm.RLMRealmConfiguration) -> RealmSwift.Realm.Configuration
  public static func convert(object: RealmSwift.Schema) -> Realm.RLMSchema
  public static func convert(object: Realm.RLMSchema) -> RealmSwift.Schema
  public static func convert(object: RealmSwift.SortDescriptor) -> Realm.RLMSortDescriptor
  public static func convert(object: Realm.RLMSortDescriptor) -> RealmSwift.SortDescriptor
  public static func convert(object: @escaping Realm.RLMShouldCompactOnLaunchBlock) -> (Swift.Int, Swift.Int) -> Swift.Bool
  public static func convert(object: @escaping (Swift.Int, Swift.Int) -> Swift.Bool) -> Realm.RLMShouldCompactOnLaunchBlock
}
@frozen public struct ObjectSchema : Swift.CustomStringConvertible {
  internal let rlmObjectSchema: Realm.RLMObjectSchema
  public var properties: [RealmSwift.Property] {
    get
  }
  public var className: Swift.String {
    get
  }
  public var objectClass: Swift.AnyClass {
    get
  }
  public var primaryKeyProperty: RealmSwift.Property? {
    get
  }
  public var description: Swift.String {
    get
  }
  public subscript(propertyName: Swift.String) -> RealmSwift.Property? {
    get
  }
}
extension ObjectSchema : Swift.Equatable {
  public static func == (lhs: RealmSwift.ObjectSchema, rhs: RealmSwift.ObjectSchema) -> Swift.Bool
}
public protocol RealmOptionalType {
}
extension RealmOptionalType {
  public static func className() -> Swift.String
}
extension Int : RealmSwift.RealmOptionalType {
}
extension Int8 : RealmSwift.RealmOptionalType {
}
extension Int16 : RealmSwift.RealmOptionalType {
}
extension Int32 : RealmSwift.RealmOptionalType {
}
extension Int64 : RealmSwift.RealmOptionalType {
}
extension Float : RealmSwift.RealmOptionalType {
}
extension Double : RealmSwift.RealmOptionalType {
}
extension Bool : RealmSwift.RealmOptionalType {
}
@available(*, deprecated, renamed: "RealmProperty", message: "RealmOptional<T> has been deprecated, use RealmProperty<T?> instead.")
final public class RealmOptional<Value> : Realm.RLMSwiftValueStorage where Value : RealmSwift.RealmOptionalType {
  final public var value: Value? {
    get
    set
  }
  public init(_ value: Value? = nil)
  @objc override dynamic public init()
  @objc deinit
}
@available(*, deprecated, message: "RealmOptional has been deprecated, use RealmProperty<T?> instead.")
extension RealmOptional : Swift.Equatable where Value : Swift.Equatable {
  public static func == (lhs: RealmSwift.RealmOptional<Value>, rhs: RealmSwift.RealmOptional<Value>) -> Swift.Bool
}
@available(*, deprecated, message: "RealmOptional has been deprecated, use RealmProperty<T?> instead.")
extension RealmOptional : Swift.Codable where Value : Swift.Decodable, Value : Swift.Encodable {
  convenience public init(from decoder: Swift.Decoder) throws
  final public func encode(to encoder: Swift.Encoder) throws
}
@frozen public struct Property : Swift.CustomStringConvertible {
  internal let rlmProperty: Realm.RLMProperty
  public var name: Swift.String {
    get
  }
  public var type: RealmSwift.PropertyType {
    get
  }
  public var isArray: Swift.Bool {
    get
  }
  public var isSet: Swift.Bool {
    get
  }
  public var isMap: Swift.Bool {
    get
  }
  public var isIndexed: Swift.Bool {
    get
  }
  public var isOptional: Swift.Bool {
    get
  }
  public var objectClassName: Swift.String? {
    get
  }
  public var description: Swift.String {
    get
  }
}
extension Property : Swift.Equatable {
  public static func == (lhs: RealmSwift.Property, rhs: RealmSwift.Property) -> Swift.Bool
}
@frozen public struct Realm {
  public var schema: RealmSwift.Schema {
    get
  }
  public var configuration: RealmSwift.Realm.Configuration {
    get
  }
  public var isEmpty: Swift.Bool {
    get
  }
  public init(queue: Dispatch.DispatchQueue? = nil) throws
  public init(configuration: RealmSwift.Realm.Configuration, queue: Dispatch.DispatchQueue? = nil) throws
  public init(fileURL: Foundation.URL) throws
  @discardableResult
  public static func asyncOpen(configuration: RealmSwift.Realm.Configuration = .defaultConfiguration, callbackQueue: Dispatch.DispatchQueue = .main, callback: @escaping (Swift.Result<RealmSwift.Realm, Swift.Error>) -> Swift.Void) -> RealmSwift.Realm.AsyncOpenTask
  @frozen public struct AsyncOpenTask {
    internal let rlmTask: Realm.RLMAsyncOpenTask
    public func cancel()
    public func addProgressNotification(queue: Dispatch.DispatchQueue = .main, block: @escaping (RealmSwift.SyncSession.Progress) -> Swift.Void)
  }
  @discardableResult
  public func write<Result>(withoutNotifying tokens: [RealmSwift.NotificationToken] = [], _ block: (() throws -> Result)) throws -> Result
  public func beginWrite()
  public func commitWrite(withoutNotifying tokens: [RealmSwift.NotificationToken] = []) throws
  public func cancelWrite()
  public var isInWriteTransaction: Swift.Bool {
    get
  }
  @frozen public enum UpdatePolicy : Swift.Int {
    case error
    case modified
    case all
    public init?(rawValue: Swift.Int)
    public typealias RawValue = Swift.Int
    public var rawValue: Swift.Int {
      get
    }
  }
  @available(*, unavailable, message: "Pass .error, .modified or .all rather than a boolean. .error is equivalent to false and .all is equivalent to true.")
  public func add(_ object: RealmSwift.Object, update: Swift.Bool)
  public func add(_ object: RealmSwift.Object, update: RealmSwift.Realm.UpdatePolicy = .error)
  @available(*, unavailable, message: "Pass .error, .modified or .all rather than a boolean. .error is equivalent to false and .all is equivalent to true.")
  public func add<S>(_ objects: S, update: Swift.Bool) where S : Swift.Sequence, S.Element : RealmSwift.Object
  public func add<S>(_ objects: S, update: RealmSwift.Realm.UpdatePolicy = .error) where S : Swift.Sequence, S.Element : RealmSwift.Object
  @discardableResult
  @available(*, unavailable, message: "Pass .error, .modified or .all rather than a boolean. .error is equivalent to false and .all is equivalent to true.")
  public func create<T>(_ type: T.Type, value: Any = [:], update: Swift.Bool) -> T where T : RealmSwift.Object
  @discardableResult
  public func create<T>(_ type: T.Type, value: Any = [:], update: RealmSwift.Realm.UpdatePolicy = .error) -> T where T : RealmSwift.Object
  @discardableResult
  @available(*, unavailable, message: "Pass .error, .modified or .all rather than a boolean. .error is equivalent to false and .all is equivalent to true.")
  public func dynamicCreate(_ typeName: Swift.String, value: Any = [:], update: Swift.Bool) -> RealmSwift.DynamicObject
  @discardableResult
  public func dynamicCreate(_ typeName: Swift.String, value: Any = [:], update: RealmSwift.Realm.UpdatePolicy = .error) -> RealmSwift.DynamicObject
  public func delete(_ object: RealmSwift.ObjectBase)
  public func delete<S>(_ objects: S) where S : Swift.Sequence, S.Element : RealmSwift.ObjectBase
  public func delete<Element>(_ objects: RealmSwift.List<Element>) where Element : RealmSwift.ObjectBase, Element : RealmSwift.RealmCollectionValue
  public func delete<Key, Value>(_ map: RealmSwift.Map<Key, Value?>) where Key : RealmSwift._MapKey, Value : RealmSwift.ObjectBase, Value : RealmSwift.RealmCollectionValue
  public func delete<Element>(_ objects: RealmSwift.Results<Element>) where Element : RealmSwift.ObjectBase, Element : RealmSwift.RealmCollectionValue
  public func deleteAll()
  public func objects<Element>(_ type: Element.Type) -> RealmSwift.Results<Element> where Element : RealmSwift.Object
  public func dynamicObjects(_ typeName: Swift.String) -> RealmSwift.Results<RealmSwift.DynamicObject>
  public func object<Element, KeyType>(ofType type: Element.Type, forPrimaryKey key: KeyType) -> Element? where Element : RealmSwift.Object
  public func dynamicObject(ofType typeName: Swift.String, forPrimaryKey key: Any) -> RealmSwift.DynamicObject?
  public func observe(_ block: @escaping RealmSwift.NotificationBlock) -> RealmSwift.NotificationToken
  public var autorefresh: Swift.Bool {
    get
    nonmutating set
  }
  @discardableResult
  public func refresh() -> Swift.Bool
  public var isFrozen: Swift.Bool {
    get
  }
  public func freeze() -> RealmSwift.Realm
  public func thaw() -> RealmSwift.Realm
  public func freeze<T>(_ obj: T) -> T where T : RealmSwift.ObjectBase
  public func thaw<T>(_ obj: T) -> T? where T : RealmSwift.ObjectBase
  public func freeze<Collection>(_ collection: Collection) -> Collection where Collection : RealmSwift.RealmCollection
  public func invalidate()
  public func writeCopy(toFile fileURL: Foundation.URL, encryptionKey: Foundation.Data? = nil) throws
  public static func fileExists(for config: RealmSwift.Realm.Configuration) -> Swift.Bool
  public static func deleteFiles(for config: RealmSwift.Realm.Configuration) throws -> Swift.Bool
  internal var rlmRealm: Realm.RLMRealm
}
extension Realm : Swift.Equatable {
  public static func == (lhs: RealmSwift.Realm, rhs: RealmSwift.Realm) -> Swift.Bool
}
extension Realm {
  @frozen public enum Notification : Swift.String {
    case didChange
    case refreshRequired
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
}
public typealias NotificationBlock = (RealmSwift.Realm.Notification, RealmSwift.Realm) -> Swift.Void
@frozen public struct RLMIterator<Element> : Swift.IteratorProtocol where Element : RealmSwift.RealmCollectionValue {
  private var generatorBase: Foundation.NSFastEnumerationIterator
  public mutating func next() -> Element?
}
public protocol _RealmMapValue {
  associatedtype Key : RealmSwift._MapKey
  associatedtype Value : RealmSwift.RealmCollectionValue
}
@frozen public struct RLMMapIterator<Element> : Swift.IteratorProtocol where Element : RealmSwift._RealmMapValue {
  private var generatorBase: Foundation.NSFastEnumerationIterator
  private var collection: Realm.RLMDictionary<Swift.AnyObject, Swift.AnyObject>
  public mutating func next() -> Element?
}
@frozen public enum RealmCollectionChange<CollectionType> {
  case initial(CollectionType)
  case update(CollectionType, deletions: [Swift.Int], insertions: [Swift.Int], modifications: [Swift.Int])
  case error(Swift.Error)
}
public protocol RealmCollectionValue : RealmSwift._RealmSchemaDiscoverable, Swift.Hashable {
  static func _nilValue() -> Self
}
extension RealmCollectionValue {
  public static func _nilValue() -> Self
}
extension Int : RealmSwift.RealmCollectionValue {
}
extension Int8 : RealmSwift.RealmCollectionValue {
}
extension Int16 : RealmSwift.RealmCollectionValue {
}
extension Int32 : RealmSwift.RealmCollectionValue {
}
extension Int64 : RealmSwift.RealmCollectionValue {
}
extension Float : RealmSwift.RealmCollectionValue {
}
extension Double : RealmSwift.RealmCollectionValue {
}
extension Bool : RealmSwift.RealmCollectionValue {
}
extension String : RealmSwift.RealmCollectionValue {
}
extension Date : RealmSwift.RealmCollectionValue {
}
extension Data : RealmSwift.RealmCollectionValue {
}
extension Decimal128 : RealmSwift.RealmCollectionValue {
}
extension ObjectId : RealmSwift.RealmCollectionValue {
}
extension UUID : RealmSwift.RealmCollectionValue {
}
extension AnyRealmValue : RealmSwift.RealmCollectionValue {
  public static func _nilValue() -> RealmSwift.AnyRealmValue
}
extension Optional : RealmSwift.RealmCollectionValue where Wrapped : RealmSwift.RealmCollectionValue {
  public static func _nilValue() -> Swift.Optional<Wrapped>
}
public protocol RealmCollectionBase : RealmSwift.ThreadConfined, Swift.CustomStringConvertible, Swift.LazyCollectionProtocol, Swift.RandomAccessCollection where Self.Element : RealmSwift.RealmCollectionValue {
  typealias ElementType = Self.Element
}
public protocol RealmCollection : RealmSwift.RealmCollectionBase {
  var realm: RealmSwift.Realm? { get }
  var isInvalidated: Swift.Bool { get }
  var count: Swift.Int { get }
  var description: Swift.String { get }
  func index(of object: Self.Element) -> Swift.Int?
  func index(matching predicate: Foundation.NSPredicate) -> Swift.Int?
  func index(matching predicateFormat: Swift.String, _ args: Any...) -> Swift.Int?
  func filter(_ predicateFormat: Swift.String, _ args: Any...) -> RealmSwift.Results<Self.Element>
  func filter(_ predicate: Foundation.NSPredicate) -> RealmSwift.Results<Self.Element>
  func sorted(byKeyPath keyPath: Swift.String, ascending: Swift.Bool) -> RealmSwift.Results<Self.Element>
  func sorted<S>(by sortDescriptors: S) -> RealmSwift.Results<Self.Element> where S : Swift.Sequence, S.Element == RealmSwift.SortDescriptor
  func min<T>(ofProperty property: Swift.String) -> T? where T : RealmSwift.MinMaxType
  func max<T>(ofProperty property: Swift.String) -> T? where T : RealmSwift.MinMaxType
  func sum<T>(ofProperty property: Swift.String) -> T where T : RealmSwift.AddableType
  func average<T>(ofProperty property: Swift.String) -> T? where T : RealmSwift.AddableType
  func value(forKey key: Swift.String) -> Any?
  func value(forKeyPath keyPath: Swift.String) -> Any?
  func setValue(_ value: Any?, forKey key: Swift.String)
  func observe(on queue: Dispatch.DispatchQueue?, _ block: @escaping (RealmSwift.RealmCollectionChange<Self>) -> Swift.Void) -> RealmSwift.NotificationToken
  func _observe(_ queue: Dispatch.DispatchQueue?, _ block: @escaping (RealmSwift.RealmCollectionChange<RealmSwift.AnyRealmCollection<Self.Element>>) -> Swift.Void) -> RealmSwift.NotificationToken
  var isFrozen: Swift.Bool { get }
  func freeze() -> Self
  func thaw() -> Self?
}
extension RealmCollection {
  public func index(matching predicateFormat: Swift.String, _ args: Any...) -> Swift.Int?
  public func filter(_ predicateFormat: Swift.String, _ args: Any...) -> RealmSwift.Results<Self.Element>
}
public protocol OptionalProtocol {
  associatedtype Wrapped
  func _rlmInferWrappedType() -> Self.Wrapped
}
extension Optional : RealmSwift.OptionalProtocol {
  public func _rlmInferWrappedType() -> Wrapped
}
extension RealmCollection where Self.Element : RealmSwift.MinMaxType {
  public func min() -> Self.Element?
  public func max() -> Self.Element?
}
extension RealmCollection where Self.Element : RealmSwift.OptionalProtocol, Self.Element.Wrapped : RealmSwift.MinMaxType {
  public func min() -> Self.Element.Wrapped?
  public func max() -> Self.Element.Wrapped?
}
extension RealmCollection where Self.Element : RealmSwift.AddableType {
  public func sum() -> Self.Element
  public func average<T>() -> T? where T : RealmSwift.AddableType
}
extension RealmCollection where Self.Element : RealmSwift.OptionalProtocol, Self.Element.Wrapped : RealmSwift.AddableType {
  public func sum() -> Self.Element.Wrapped
  public func average<T>() -> T? where T : RealmSwift.AddableType
}
extension RealmCollection where Self.Element : Swift.Comparable {
  public func sorted(ascending: Swift.Bool = true) -> RealmSwift.Results<Self.Element>
}
extension RealmCollection where Self.Element : RealmSwift.OptionalProtocol, Self.Element.Wrapped : Swift.Comparable {
  public func sorted(ascending: Swift.Bool = true) -> RealmSwift.Results<Self.Element>
}
public struct AnyRealmCollection<Element> : RealmSwift.RealmCollection where Element : RealmSwift.RealmCollectionValue {
  public typealias ElementType = Element
  public func index(after i: Swift.Int) -> Swift.Int
  public func index(before i: Swift.Int) -> Swift.Int
  public init<C>(_ base: C) where Element == C.Element, C : RealmSwift.RealmCollection
  public var realm: RealmSwift.Realm? {
    get
  }
  public var isInvalidated: Swift.Bool {
    get
  }
  public var count: Swift.Int {
    get
  }
  public var description: Swift.String {
    get
  }
  public func index(of object: Element) -> Swift.Int?
  public func index(matching predicate: Foundation.NSPredicate) -> Swift.Int?
  public func filter(_ predicate: Foundation.NSPredicate) -> RealmSwift.Results<Element>
  public func sorted(byKeyPath keyPath: Swift.String, ascending: Swift.Bool) -> RealmSwift.Results<Element>
  public func sorted<S>(by sortDescriptors: S) -> RealmSwift.Results<Element> where S : Swift.Sequence, S.Element == RealmSwift.SortDescriptor
  public func min<T>(ofProperty property: Swift.String) -> T? where T : RealmSwift.MinMaxType
  public func max<T>(ofProperty property: Swift.String) -> T? where T : RealmSwift.MinMaxType
  public func sum<T>(ofProperty property: Swift.String) -> T where T : RealmSwift.AddableType
  public func average<T>(ofProperty property: Swift.String) -> T? where T : RealmSwift.AddableType
  public subscript(position: Swift.Int) -> Element {
    get
  }
  public func makeIterator() -> RealmSwift.RLMIterator<Element>
  public var startIndex: Swift.Int {
    get
  }
  public var endIndex: Swift.Int {
    get
  }
  public func value(forKey key: Swift.String) -> Any?
  public func value(forKeyPath keyPath: Swift.String) -> Any?
  public func setValue(_ value: Any?, forKey key: Swift.String)
  public func observe(on queue: Dispatch.DispatchQueue? = nil, _ block: @escaping (RealmSwift.RealmCollectionChange<RealmSwift.AnyRealmCollection<Element>>) -> Swift.Void) -> RealmSwift.NotificationToken
  public func _observe(_ queue: Dispatch.DispatchQueue?, _ block: @escaping (RealmSwift.RealmCollectionChange<RealmSwift.AnyRealmCollection<Element>>) -> Swift.Void) -> RealmSwift.NotificationToken
  public var isFrozen: Swift.Bool {
    get
  }
  public func freeze() -> RealmSwift.AnyRealmCollection<Element>
  public func thaw() -> RealmSwift.AnyRealmCollection<Element>?
  public typealias Elements = RealmSwift.AnyRealmCollection<Element>
  public typealias Index = Swift.Int
  public typealias Indices = Swift.Range<Swift.Int>
  public typealias Iterator = RealmSwift.RLMIterator<Element>
  public typealias SubSequence = Swift.Slice<RealmSwift.AnyRealmCollection<Element>>
}
extension Realm {
  @frozen public struct Configuration {
    public static var defaultConfiguration: RealmSwift.Realm.Configuration {
      get
      set
    }
    public init(fileURL: Foundation.URL? = URL(fileURLWithPath: RLMRealmPathForFile("default.realm"), isDirectory: false), inMemoryIdentifier: Swift.String? = nil, syncConfiguration: RealmSwift.SyncConfiguration? = nil, encryptionKey: Foundation.Data? = nil, readOnly: Swift.Bool = false, schemaVersion: Swift.UInt64 = 0, migrationBlock: RealmSwift.MigrationBlock? = nil, deleteRealmIfMigrationNeeded: Swift.Bool = false, shouldCompactOnLaunch: ((Swift.Int, Swift.Int) -> Swift.Bool)? = nil, objectTypes: [RealmSwift.ObjectBase.Type]? = nil)
    public var syncConfiguration: RealmSwift.SyncConfiguration? {
      get
      set
    }
    private var _syncConfiguration: RealmSwift.SyncConfiguration?
    public var fileURL: Foundation.URL? {
      get
      set
    }
    private var _path: Swift.String?
    public var inMemoryIdentifier: Swift.String? {
      get
      set
    }
    private var _inMemoryIdentifier: Swift.String?
    public var encryptionKey: Foundation.Data?
    public var readOnly: Swift.Bool = false
    public var schemaVersion: Swift.UInt64 = 0
    public var migrationBlock: RealmSwift.MigrationBlock?
    public var deleteRealmIfMigrationNeeded: Swift.Bool {
      get
      set(newValue)
    }
    private var _deleteRealmIfMigrationNeeded: Swift.Bool = false
    public var shouldCompactOnLaunch: ((Swift.Int, Swift.Int) -> Swift.Bool)?
    public var objectTypes: [RealmSwift.ObjectBase.Type]? {
      get
      set
    }
    public var maximumNumberOfActiveVersions: Swift.UInt?
    private var customSchema: Realm.RLMSchema?
    internal var disableFormatUpgrade: Swift.Bool = false
  }
}
extension Realm.Configuration : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
extension Realm.Configuration : Swift.Equatable {
  public static func == (lhs: RealmSwift.Realm.Configuration, rhs: RealmSwift.Realm.Configuration) -> Swift.Bool
}
public protocol RealmKeyedCollection : RealmSwift.ThreadConfined, Swift.CustomStringConvertible, Swift.Sequence {
  associatedtype Key : RealmSwift._MapKey
  associatedtype Value : RealmSwift.RealmCollectionValue
  var realm: RealmSwift.Realm? { get }
  var isInvalidated: Swift.Bool { get }
  var count: Swift.Int { get }
  var description: Swift.String { get }
  func updateValue(_ value: Self.Value, forKey key: Self.Key)
  func removeObject(for key: Self.Key)
  func removeAll()
  subscript(key: Self.Key) -> Self.Value? { get set }
  func value(forKey key: Swift.String) -> Swift.AnyObject?
  func value(forKeyPath keyPath: Swift.String) -> Swift.AnyObject?
  func setValue(_ value: Any?, forKey key: Swift.String)
  func filter(_ predicate: Foundation.NSPredicate) -> RealmSwift.Results<Self.Value>
  func contains(where predicate: @escaping (Self.Key, Self.Value) -> Swift.Bool) -> Swift.Bool
  func sorted(ascending: Swift.Bool) -> RealmSwift.Results<Self.Value>
  func sorted(byKeyPath keyPath: Swift.String, ascending: Swift.Bool) -> RealmSwift.Results<Self.Value>
  func sorted<S>(by sortDescriptors: S) -> RealmSwift.Results<Self.Value> where S : Swift.Sequence, S.Element == RealmSwift.SortDescriptor
  var keys: [Self.Key] { get }
  var values: [Self.Value] { get }
  func min<T>(ofProperty property: Swift.String) -> T? where T : RealmSwift.MinMaxType
  func max<T>(ofProperty property: Swift.String) -> T? where T : RealmSwift.MinMaxType
  func sum<T>(ofProperty property: Swift.String) -> T where T : RealmSwift.AddableType
  func average<T>(ofProperty property: Swift.String) -> T? where T : RealmSwift.AddableType
  func observe(on queue: Dispatch.DispatchQueue?, _ block: @escaping (RealmSwift.RealmMapChange<Self>) -> Swift.Void) -> RealmSwift.NotificationToken
  var isFrozen: Swift.Bool { get }
  func freeze() -> Self
  func thaw() -> Self?
}
extension RealmKeyedCollection where Self.Value : RealmSwift.MinMaxType {
  public func min() -> Self.Value?
  public func max() -> Self.Value?
}
extension RealmKeyedCollection where Self.Value : RealmSwift.OptionalProtocol, Self.Value.Wrapped : RealmSwift.MinMaxType {
  public func min() -> Self.Value.Wrapped?
  public func max() -> Self.Value.Wrapped?
}
extension RealmKeyedCollection where Self.Value : RealmSwift.AddableType {
  public func sum() -> Self.Value
  public func average<T>() -> T? where T : RealmSwift.AddableType
}
extension RealmKeyedCollection where Self.Value : RealmSwift.OptionalProtocol, Self.Value.Wrapped : RealmSwift.AddableType {
  public func sum() -> Self.Value.Wrapped
  public func average<T>() -> T? where T : RealmSwift.AddableType
}
extension RealmKeyedCollection where Self.Value : Swift.Comparable {
  public func sorted(ascending: Swift.Bool = true) -> RealmSwift.Results<Self.Value>
}
extension RealmKeyedCollection where Self.Value : RealmSwift.OptionalProtocol, Self.Value.Wrapped : Swift.Comparable {
  public func sorted(ascending: Swift.Bool = true) -> RealmSwift.Results<Self.Value>
}
@_inheritsConvenienceInitializers final public class RealmProperty<Value> : Realm.RLMSwiftValueStorage where Value : RealmSwift.RealmPropertyType {
  final public var value: Value {
    get
    set
  }
  @objc override final public var description: Swift.String {
    @objc get
  }
  @objc override dynamic public init()
  @objc deinit
}
extension RealmProperty : Swift.Equatable where Value : Swift.Equatable {
  public static func == (lhs: RealmSwift.RealmProperty<Value>, rhs: RealmSwift.RealmProperty<Value>) -> Swift.Bool
}
extension RealmProperty : Swift.Codable where Value : Swift.Decodable, Value : Swift.Encodable {
  convenience public init(from decoder: Swift.Decoder) throws
  final public func encode(to encoder: Swift.Encoder) throws
}
public protocol RealmPropertyType {
}
extension AnyRealmValue : RealmSwift.RealmPropertyType {
}
extension Optional : RealmSwift.RealmPropertyType where Wrapped : RealmSwift.RealmOptionalType {
}
public protocol MinMaxType {
}
extension NSNumber : RealmSwift.MinMaxType {
}
extension Double : RealmSwift.MinMaxType {
}
extension Float : RealmSwift.MinMaxType {
}
extension Int : RealmSwift.MinMaxType {
}
extension Int8 : RealmSwift.MinMaxType {
}
extension Int16 : RealmSwift.MinMaxType {
}
extension Int32 : RealmSwift.MinMaxType {
}
extension Int64 : RealmSwift.MinMaxType {
}
extension Date : RealmSwift.MinMaxType {
}
extension NSDate : RealmSwift.MinMaxType {
}
extension Decimal128 : RealmSwift.MinMaxType {
}
extension AnyRealmValue : RealmSwift.MinMaxType {
}
public protocol AddableType {
  init()
}
extension NSNumber : RealmSwift.AddableType {
}
extension Double : RealmSwift.AddableType {
}
extension Float : RealmSwift.AddableType {
}
extension Int : RealmSwift.AddableType {
}
extension Int8 : RealmSwift.AddableType {
}
extension Int16 : RealmSwift.AddableType {
}
extension Int32 : RealmSwift.AddableType {
}
extension Int64 : RealmSwift.AddableType {
}
extension Decimal128 : RealmSwift.AddableType {
}
extension AnyRealmValue : RealmSwift.AddableType {
}
@frozen public struct Results<Element> : Swift.Equatable where Element : RealmSwift.RealmCollectionValue {
  internal let rlmResults: Realm.RLMResults<Swift.AnyObject>
  public var description: Swift.String {
    get
  }
  public typealias ElementType = Element
  public var realm: RealmSwift.Realm? {
    get
  }
  public var isInvalidated: Swift.Bool {
    get
  }
  public var count: Swift.Int {
    get
  }
  public func index(of object: Element) -> Swift.Int?
  public func index(matching predicate: Foundation.NSPredicate) -> Swift.Int?
  public subscript(position: Swift.Int) -> Element {
    get
  }
  public var first: Element? {
    get
  }
  public var last: Element? {
    get
  }
  public func value(forKey key: Swift.String) -> Any?
  public func value(forKeyPath keyPath: Swift.String) -> Any?
  public func setValue(_ value: Any?, forKey key: Swift.String)
  public func filter(_ predicate: Foundation.NSPredicate) -> RealmSwift.Results<Element>
  public func sorted(byKeyPath keyPath: Swift.String, ascending: Swift.Bool = true) -> RealmSwift.Results<Element>
  public func sorted<S>(by sortDescriptors: S) -> RealmSwift.Results<Element> where S : Swift.Sequence, S.Element == RealmSwift.SortDescriptor
  public func distinct<S>(by keyPaths: S) -> RealmSwift.Results<Element> where S : Swift.Sequence, S.Element == Swift.String
  public func min<T>(ofProperty property: Swift.String) -> T? where T : RealmSwift.MinMaxType
  public func max<T>(ofProperty property: Swift.String) -> T? where T : RealmSwift.MinMaxType
  public func sum<T>(ofProperty property: Swift.String) -> T where T : RealmSwift.AddableType
  public func average<T>(ofProperty property: Swift.String) -> T? where T : RealmSwift.AddableType
  public func observe(on queue: Dispatch.DispatchQueue? = nil, _ block: @escaping (RealmSwift.RealmCollectionChange<RealmSwift.Results<Element>>) -> Swift.Void) -> RealmSwift.NotificationToken
  public var isFrozen: Swift.Bool {
    get
  }
  public func freeze() -> RealmSwift.Results<Element>
  public func thaw() -> RealmSwift.Results<Element>?
  public static func == (a: RealmSwift.Results<Element>, b: RealmSwift.Results<Element>) -> Swift.Bool
}
extension Results : RealmSwift.RealmCollection {
  public func makeIterator() -> RealmSwift.RLMIterator<Element>
  public var startIndex: Swift.Int {
    get
  }
  public var endIndex: Swift.Int {
    get
  }
  public func index(after i: Swift.Int) -> Swift.Int
  public func index(before i: Swift.Int) -> Swift.Int
  public func _observe(_ queue: Dispatch.DispatchQueue?, _ block: @escaping (RealmSwift.RealmCollectionChange<RealmSwift.AnyRealmCollection<Element>>) -> Swift.Void) -> RealmSwift.NotificationToken
  public typealias Elements = RealmSwift.Results<Element>
  public typealias Index = Swift.Int
  public typealias Indices = Swift.Range<Swift.Int>
  public typealias Iterator = RealmSwift.RLMIterator<Element>
  public typealias SubSequence = Swift.Slice<RealmSwift.Results<Element>>
}
extension Results : Swift.Encodable where Element : Swift.Encodable {
  public func encode(to encoder: Swift.Encoder) throws
}
extension RLMRealm {
  @nonobjc public class func schemaVersion(at url: Foundation.URL, usingEncryptionKey key: Foundation.Data? = nil) throws -> Swift.UInt64
  @nonobjc public func resolve<Confined>(reference: Realm.RLMThreadSafeReference<Confined>) -> Confined? where Confined : Realm.RLMThreadConfined
}
extension RLMObject {
  public class func objects(where predicateFormat: Swift.String, _ args: Swift.CVarArg...) -> Realm.RLMResults<Realm.RLMObject>
  public class func objects(in realm: Realm.RLMRealm, where predicateFormat: Swift.String, _ args: Swift.CVarArg...) -> Realm.RLMResults<Realm.RLMObject>
}
public protocol _RLMCollectionIterator {
  func makeIterator() -> RealmSwift.RLMCollectionIterator
}
extension _RLMCollectionIterator where Self : Realm.RLMCollection {
  public func makeIterator() -> RealmSwift.RLMCollectionIterator
}
public typealias RLMDictionarySingleEntry = (key: Swift.String, value: Realm.RLMObject)
public protocol _RLMDictionaryIterator {
  func makeIterator() -> RealmSwift.RLMDictionaryIterator
}
extension _RLMDictionaryIterator where Self : Realm.RLMCollection {
  public func makeIterator() -> RealmSwift.RLMDictionaryIterator
}
extension RLMArray : Swift.Sequence, RealmSwift._RLMCollectionIterator {
  public typealias Element = Realm.RLMObject
  public typealias Iterator = RealmSwift.RLMCollectionIterator
}
extension RLMDictionary : Swift.Sequence, RealmSwift._RLMDictionaryIterator {
  public typealias Element = (key: Swift.String, value: Realm.RLMObject)
  public typealias Iterator = RealmSwift.RLMDictionaryIterator
}
extension RLMSet : Swift.Sequence, RealmSwift._RLMCollectionIterator {
  public typealias Element = Realm.RLMObject
  public typealias Iterator = RealmSwift.RLMCollectionIterator
}
extension RLMResults : Swift.Sequence, RealmSwift._RLMCollectionIterator {
  public typealias Element = Realm.RLMObject
  public typealias Iterator = RealmSwift.RLMCollectionIterator
}
public struct RLMCollectionIterator : Swift.IteratorProtocol {
  public mutating func next() -> Realm.RLMObject?
  public typealias Element = Realm.RLMObject
}
public struct RLMDictionaryIterator : Swift.IteratorProtocol {
  public mutating func next() -> RealmSwift.RLMDictionarySingleEntry?
  public typealias Element = (key: Swift.String, value: Realm.RLMObject)
}
extension RLMCollection {
  public func indexOfObject(where predicateFormat: Swift.String, _ args: Swift.CVarArg...) -> Swift.UInt
  public func objects(where predicateFormat: Swift.String, _ args: Swift.CVarArg...) -> Realm.RLMResults<ObjectiveC.NSObject>
}
extension RLMCollection {
  public subscript(key: Swift.String) -> Swift.AnyObject? {
    get
    set
  }
}
@frozen public struct Schema : Swift.CustomStringConvertible {
  internal let rlmSchema: Realm.RLMSchema
  public var objectSchema: [RealmSwift.ObjectSchema] {
    get
  }
  public var description: Swift.String {
    get
  }
  public subscript(className: Swift.String) -> RealmSwift.ObjectSchema? {
    get
  }
}
extension Schema : Swift.Equatable {
  public static func == (lhs: RealmSwift.Schema, rhs: RealmSwift.Schema) -> Swift.Bool
}
public protocol _RealmSchemaDiscoverable {
  static var _rlmType: RealmSwift.PropertyType { get }
  static var _rlmOptional: Swift.Bool { get }
  func _rlmPopulateProperty(_ prop: Realm.RLMProperty)
  static func _rlmPopulateProperty(_ prop: Realm.RLMProperty)
  static var _rlmRequireObjc: Swift.Bool { get }
}
extension _RealmSchemaDiscoverable {
  public static var _rlmOptional: Swift.Bool {
    get
  }
  public static var _rlmRequireObjc: Swift.Bool {
    get
  }
  public func _rlmPopulateProperty(_ prop: Realm.RLMProperty)
  public static func _rlmPopulateProperty(_ prop: Realm.RLMProperty)
}
@frozen public struct SortDescriptor {
  public let keyPath: Swift.String
  public let ascending: Swift.Bool
  public init(keyPath: Swift.String, ascending: Swift.Bool = true)
  public func reversed() -> RealmSwift.SortDescriptor
}
extension SortDescriptor : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
extension SortDescriptor : Swift.Equatable {
  public static func == (lhs: RealmSwift.SortDescriptor, rhs: RealmSwift.SortDescriptor) -> Swift.Bool
}
extension SortDescriptor : Swift.ExpressibleByStringLiteral {
  public typealias UnicodeScalarLiteralType = Swift.StringLiteralType
  public typealias ExtendedGraphemeClusterLiteralType = Swift.StringLiteralType
  public init(stringLiteral value: Swift.StringLiteralType)
  public typealias StringLiteralType = Swift.StringLiteralType
}
public typealias User = Realm.RLMUser
extension RLMUser {
  public func linkUser(credentials: RealmSwift.Credentials, _ completion: @escaping (Swift.Result<RealmSwift.User, Swift.Error>) -> Swift.Void)
}
public typealias SyncManager = Realm.RLMSyncManager
public typealias SyncTimeoutOptions = Realm.RLMSyncTimeoutOptions
public typealias SyncSession = Realm.RLMSyncSession
public typealias ErrorReportingBlock = Realm.RLMSyncErrorReportingBlock
public typealias UserCompletionBlock = Realm.RLMUserCompletionBlock
public typealias SyncError = Realm.RLMSyncError
extension RLMSyncError {
  public typealias ActionToken = Realm.RLMSyncErrorActionToken
  public func clientResetInfo() -> (Swift.String, RealmSwift.SyncError.ActionToken)?
  public func deleteRealmUserInfo() -> RealmSwift.SyncError.ActionToken?
}
public typealias SyncAuthError = Realm.RLMSyncAuthError
public typealias SyncLogLevel = Realm.RLMSyncLogLevel
public typealias Provider = Realm.RLMIdentityProvider
@frozen public enum ServerValidationPolicy {
  case none
  case system
  case pinCertificate(path: Foundation.URL)
}
@frozen public struct SyncConfiguration {
  public let user: RealmSwift.User
  public let partitionValue: RealmSwift.AnyBSON?
  internal let stopPolicy: Realm.RLMSyncStopPolicy
  public let cancelAsyncOpenOnNonFatalErrors: Swift.Bool
}
@dynamicMemberLookup @frozen public struct Functions {
  private let user: RealmSwift.User
  public typealias FunctionCompletionHandler = (RealmSwift.AnyBSON?, Swift.Error?) -> Swift.Void
  public typealias Function = ([RealmSwift.AnyBSON], @escaping RealmSwift.Functions.FunctionCompletionHandler) -> Swift.Void
  public subscript(dynamicMember string: Swift.String) -> RealmSwift.Functions.Function {
    get
  }
  public typealias ResultFunctionCompletionHandler = (Swift.Result<RealmSwift.AnyBSON, Swift.Error>) -> Swift.Void
  public typealias ResultFunction = ([RealmSwift.AnyBSON], @escaping RealmSwift.Functions.ResultFunctionCompletionHandler) -> Swift.Void
  public subscript(dynamicMember string: Swift.String) -> RealmSwift.Functions.ResultFunction {
    get
  }
}
extension RLMUser {
  public func configuration<T>(partitionValue: T) -> RealmSwift.Realm.Configuration where T : RealmSwift.BSON
  public func configuration(partitionValue: RealmSwift.AnyBSON, cancelAsyncOpenOnNonFatalErrors: Swift.Bool = false) -> RealmSwift.Realm.Configuration
  public func configuration<T>(partitionValue: T, cancelAsyncOpenOnNonFatalErrors: Swift.Bool = false) -> RealmSwift.Realm.Configuration where T : RealmSwift.BSON
  public var customData: RealmSwift.Document {
    get
  }
  public func mongoClient(_ serviceName: Swift.String) -> RealmSwift.MongoClient
  public var functions: RealmSwift.Functions {
    get
  }
}
extension RLMSyncSession {
  public typealias State = Realm.RLMSyncSessionState
  public typealias ConnectionState = Realm.RLMSyncConnectionState
  public enum ProgressDirection {
    case upload
    case download
    public static func == (a: Realm.RLMSyncSession.ProgressDirection, b: Realm.RLMSyncSession.ProgressDirection) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public enum ProgressMode {
    case reportIndefinitely
    case forCurrentlyOutstandingWork
    public static func == (a: Realm.RLMSyncSession.ProgressMode, b: Realm.RLMSyncSession.ProgressMode) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public typealias ProgressNotificationToken = Realm.RLMProgressNotificationToken
  public struct Progress {
    public let transferredBytes: Swift.Int
    public let transferrableBytes: Swift.Int
    public var fractionTransferred: Swift.Double {
      get
    }
    public var isTransferComplete: Swift.Bool {
      get
    }
  }
  public func addProgressNotification(for direction: Realm.RLMSyncSession.ProgressDirection, mode: Realm.RLMSyncSession.ProgressMode, block: @escaping (Realm.RLMSyncSession.Progress) -> Swift.Void) -> Realm.RLMSyncSession.ProgressNotificationToken?
}
extension Realm {
  @available(*, unavailable, message: "Use Results.subscribe()")
  public func subscribe<T>(to objects: T.Type, where: Swift.String, completion: @escaping (RealmSwift.Results<T>?, Swift.Error?) -> Swift.Void) where T : RealmSwift.Object
  public var syncSession: RealmSwift.SyncSession? {
    get
  }
}
extension RLMUser {
  public func refreshCustomData(_ completion: @escaping (Swift.Result<[Swift.AnyHashable : Any], Swift.Error>) -> Swift.Void)
}
public protocol ThreadConfined {
  var realm: RealmSwift.Realm? { get }
  var isInvalidated: Swift.Bool { get }
  var isFrozen: Swift.Bool { get }
  func freeze() -> Self
  func thaw() -> Self?
}
@frozen public struct ThreadSafeReference<Confined> where Confined : RealmSwift.ThreadConfined {
  private let swiftMetadata: Any?
  public var isInvalidated: Swift.Bool {
    get
  }
  private let objectiveCReference: Realm.RLMThreadSafeReference<Realm.RLMThreadConfined>
  public init(to threadConfined: Confined)
}
extension Realm {
  public func resolve<Confined>(_ reference: RealmSwift.ThreadSafeReference<Confined>) -> Confined? where Confined : RealmSwift.ThreadConfined
}
public func dynamicBridgeCast<T>(fromObjectiveC x: Any) -> T
public func dynamicBridgeCast<T>(fromSwift x: T) -> Any
extension RealmSwift.Realm.UpdatePolicy : Swift.Equatable {}
extension RealmSwift.Realm.UpdatePolicy : Swift.Hashable {}
extension RealmSwift.Realm.UpdatePolicy : Swift.RawRepresentable {}
extension RealmSwift.Realm.Notification : Swift.Equatable {}
extension RealmSwift.Realm.Notification : Swift.Hashable {}
extension RealmSwift.Realm.Notification : Swift.RawRepresentable {}
extension Realm.RLMSyncSession.ProgressDirection : Swift.Equatable {}
extension Realm.RLMSyncSession.ProgressDirection : Swift.Hashable {}
extension Realm.RLMSyncSession.ProgressMode : Swift.Equatable {}
extension Realm.RLMSyncSession.ProgressMode : Swift.Hashable {}
